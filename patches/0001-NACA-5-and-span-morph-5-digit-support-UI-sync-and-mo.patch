From d2d1616fe9ab83c36a04ea0707e21463f60fa70a Mon Sep 17 00:00:00 2001
From: onkanat <47117474+onkanat@users.noreply.github.com>
Date: Wed, 5 Nov 2025 07:15:24 +0300
Subject: [PATCH] =?UTF-8?q?NACA-5=20and=20span=E2=80=91morph:=205-digit=20?=
 =?UTF-8?q?support,=20UI=20sync=20and=20mode-state=20persistence?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Integrate NACA-5 selection for mesh and span-morph
- Auto-apply left panel inputs (remove Apply button) and debounce changes
- Persist geometry & morph params into URL (history.replaceState) so normal <-> cinematic preserve state
- Expose resetDefaults() and getCurrentValues() from addSpanMorphUI
- Prevent duplicate span-morph panels in cinematic mode

Testing notes:
- Hard-refresh then change NACA and morph sliders in Normal; verify URL updates and cinematic mode reflects values.
- Ctrl/Cmd+M toggles mode and preserves state.

Risks:
- URL-based state persistence can be reverted if undesired by maintainer.
---
 frontend/animate.foil.js | 121 +++++++++++++++++++------
 frontend/nacaprofile.js  |  95 ++++++++++++++++++++
 frontend/utils.js        |  54 ++++++++----
 frontend/wing.js         | 185 +++++++++++++++++++++++++++++++--------
 4 files changed, 376 insertions(+), 79 deletions(-)

diff --git a/frontend/animate.foil.js b/frontend/animate.foil.js
index 58d0f4e..ff3141e 100644
--- a/frontend/animate.foil.js
+++ b/frontend/animate.foil.js
@@ -1,16 +1,36 @@
 // animateFoil.js
 import * as THREE from 'three';
 import { addSpanMorphUI } from './utils.js';
-import { naca4Coordinates } from './nacaprofile.js';
+import { naca4Coordinates, naca5Coordinates } from './nacaprofile.js';
 
 export function animateFoil(scene, foil, renderer, camera, controls, duration = 30, fps = 60) {
     // OrbitControls'u devre dışı bırak (kamera animasyonu sırasında)
     controls.enabled = false;
 
-    // controller ile span morph ve dihedral kontrolü
-    let controller = addSpanMorphUI({
-        naca: '4430', chord: 1.0, points: 200, depth: 3, scale: 3.0
-    }, foil, naca4Coordinates);
+    // read initial parameters from URL so cinematic mode mirrors normal mode state
+    let initParams = { naca: '4430', chord: 1.0, points: 200, depth: 3, scale: 3.0 };
+    try {
+        const p = new URLSearchParams(window.location.search);
+        const n = p.get('naca'); if (n) initParams.naca = String(n).replace(/\D/g, '');
+        const chord = parseFloat(p.get('chord')); if (!Number.isNaN(chord)) initParams.chord = chord;
+        const points = parseInt(p.get('points'), 10); if (!Number.isNaN(points)) initParams.points = points;
+        const depth = parseFloat(p.get('depth')); if (!Number.isNaN(depth)) initParams.depth = depth;
+        const scale = parseFloat(p.get('scale')); if (!Number.isNaN(scale)) initParams.scale = scale;
+    } catch (e) { }
+
+    // read span morph params from URL
+    let initSpan = {};
+    try {
+        const p = new URLSearchParams(window.location.search);
+        const s = parseFloat(p.get('start')); if (!Number.isNaN(s)) initSpan.startPercent = Math.max(0, Math.min(1, s));
+        const f = parseFloat(p.get('factor')); if (!Number.isNaN(f)) initSpan.thicknessFactor = f;
+        const slices = parseInt(p.get('slices'), 10); if (!Number.isNaN(slices)) initSpan.slices = slices;
+        const shift = parseFloat(p.get('shift')); if (!Number.isNaN(shift)) initSpan.shiftAmount = shift;
+        const dihedral = parseFloat(p.get('dihedral')); if (!Number.isNaN(dihedral)) initSpan.dihedralAngle = dihedral * Math.PI / 180;
+    } catch (e) { }
+
+    // controller ile span morph ve dihedral kontrolü (no panel)
+    let controller = addSpanMorphUI(initParams, foil, naca4Coordinates, Object.assign({ appendPanel: false }, initSpan));
 
     // --- Mirror the right wing ---
     const rightWing = foil.clone();
@@ -19,9 +39,7 @@ export function animateFoil(scene, foil, renderer, camera, controls, duration =
     scene.add(rightWing);
 
     // Create a second controller for the right wing so it can be morphed independently
-    let rightController = addSpanMorphUI({
-        naca: '4430', chord: 1.0, points: 200, depth: 3, scale: 3.0
-    }, rightWing, naca4Coordinates);
+    let rightController = addSpanMorphUI(initParams, rightWing, naca4Coordinates, Object.assign({ appendPanel: false }, initSpan));
 
     // ✨ CHARMING EFFECT 1: Dynamic Directional Light (Kamera ile hareket eden ışık)
     const dynamicLight = new THREE.DirectionalLight(0xffd4a3, 2);
@@ -31,12 +49,12 @@ export function animateFoil(scene, foil, renderer, camera, controls, duration =
     const rimLight = new THREE.DirectionalLight(0x4488ff, 1.5);
     scene.add(rimLight);
 
-    // Kullanıcı kontrollü parametreler (UI'dan değişecek)
-    let startPercent = 0.5;
-    let thicknessFactor = 1.0;
-    let shiftAmount = 0.0;
-    let dihedralAngle = 0.0;
-    let nacaCode = '4430';
+    // Kullanıcı kontrollü parametreler (UI'dan değişecek) — initialize from URL-derived values
+    let startPercent = (typeof initSpan.startPercent === 'number') ? initSpan.startPercent : 0.5;
+    let thicknessFactor = (typeof initSpan.thicknessFactor === 'number') ? initSpan.thicknessFactor : 1.0;
+    let shiftAmount = (typeof initSpan.shiftAmount === 'number') ? initSpan.shiftAmount : 0.0;
+    let dihedralAngle = (typeof initSpan.dihedralAngle === 'number') ? initSpan.dihedralAngle : 0.0;
+    let nacaCode = initParams.naca || '4430';
 
     let frameCounter = 0;
 
@@ -181,7 +199,7 @@ export function animateFoil(scene, foil, renderer, camera, controls, duration =
         return { container, slider, valueDisplay, unit };
     }
 
-    function createTextInput(label, defaultValue) {
+    function createTextInput(label, defaultValue, maxLen = 4) {
         const container = document.createElement('div');
         container.style.marginBottom = '15px';
 
@@ -193,7 +211,7 @@ export function animateFoil(scene, foil, renderer, camera, controls, duration =
         const input = document.createElement('input');
         input.type = 'text';
         input.value = defaultValue;
-        input.maxLength = 4;
+        input.maxLength = maxLen;
         Object.assign(input.style, {
             width: '100%',
             padding: '8px',
@@ -213,7 +231,11 @@ export function animateFoil(scene, foil, renderer, camera, controls, duration =
     }
 
     // NACA Input
-    const nacaInput = createTextInput('NACA Airfoil', nacaCode);
+    // make this input accept 4 or 5 digits (user will type 4-digit normally,
+    // but we allow 5-digit entries for cinematic override)
+    const nacaInput = createTextInput('NACA Airfoil (4 or 5 digits)', nacaCode, 5);
+    // only allow digits while typing
+    nacaInput.input.addEventListener('input', (e) => { e.target.value = e.target.value.replace(/[^0-9]/g, '').slice(0, 5); });
     controlPanel.appendChild(nacaInput.container);
 
     // Cranked Wing Slider
@@ -235,27 +257,47 @@ export function animateFoil(scene, foil, renderer, camera, controls, duration =
     document.body.appendChild(controlPanel);
 
     // NACA değişimi için rebuild fonksiyonu
+
     function rebuildWithNewNACA(newNaca) {
-        const nacaStr = String(newNaca).padStart(4, '0');
+        const raw = String(newNaca).replace(/\D/g, '');
+        let coordsFunc = naca4Coordinates;
+        let nacaStr = '2412';
+        if (raw.length === 5) {
+            nacaStr = raw;
+            coordsFunc = naca5Coordinates;
+        } else if (raw.length === 4) {
+            nacaStr = raw.padStart(4, '0');
+            coordsFunc = naca4Coordinates;
+        } else {
+            // fallback keep previous
+            nacaStr = controller ? (controller.naca || '2412') : '2412';
+        }
 
-        // Sol kanat için yeni controller
-        controller = addSpanMorphUI({
-            naca: nacaStr, chord: 1.0, points: 200, depth: 3, scale: 3.0
-        }, foil, naca4Coordinates);
+        // Sol kanat için yeni controller (panel eklenmesin)
+        controller = addSpanMorphUI({ naca: nacaStr, chord: initParams.chord, points: initParams.points, depth: initParams.depth, scale: initParams.scale }, foil, coordsFunc, { appendPanel: false });
 
-        // Sağ kanat için yeni controller
-        rightController = addSpanMorphUI({
-            naca: nacaStr, chord: 1.0, points: 200, depth: 3, scale: 3.0
-        }, rightWing, naca4Coordinates);
+        // Sağ kanat için yeni controller (panel eklenmesin)
+        rightController = addSpanMorphUI({ naca: nacaStr, chord: initParams.chord, points: initParams.points, depth: initParams.depth, scale: initParams.scale }, rightWing, coordsFunc, { appendPanel: false });
 
         // Mevcut morph parametrelerini uygula
+        // update local naca code and reapply morphs
+        nacaCode = nacaStr;
         controller.applySpanMorph(startPercent, thicknessFactor, 40, shiftAmount, dihedralAngle);
         rightController.applySpanMorph(startPercent, thicknessFactor, 40, shiftAmount, dihedralAngle);
+
+        // update URL so the new NACA is visible to normal mode when toggling back
+        try {
+            const ps = new URLSearchParams(window.location.search);
+            ps.set('naca', nacaStr);
+            // preserve mode (cinematic)
+            ps.set('mode', 'cinematic');
+            history.replaceState(null, '', '?' + ps.toString());
+        } catch (e) { }
     }
 
     // Event listeners for UI controls
     nacaInput.input.addEventListener('input', (e) => {
-        nacaCode = e.target.value.padStart(4, '0');
+        nacaCode = e.target.value;
     });
 
     // NACA input için Enter veya blur eventi
@@ -275,6 +317,13 @@ export function animateFoil(scene, foil, renderer, camera, controls, duration =
         crankedSlider.valueDisplay.textContent = startPercent.toFixed(2);
         controller.applySpanMorph(startPercent, thicknessFactor, 40, shiftAmount, dihedralAngle);
         rightController.applySpanMorph(startPercent, thicknessFactor, 40, shiftAmount, dihedralAngle);
+        // persist span morph values to URL so normal mode picks them up
+        try {
+            const ps = new URLSearchParams(window.location.search);
+            ps.set('start', String(startPercent));
+            ps.set('mode', 'cinematic');
+            history.replaceState(null, '', '?' + ps.toString());
+        } catch (e) { }
     });
 
     taperSlider.slider.addEventListener('input', (e) => {
@@ -282,6 +331,12 @@ export function animateFoil(scene, foil, renderer, camera, controls, duration =
         taperSlider.valueDisplay.textContent = thicknessFactor.toFixed(2);
         controller.applySpanMorph(startPercent, thicknessFactor, 40, shiftAmount, dihedralAngle);
         rightController.applySpanMorph(startPercent, thicknessFactor, 40, shiftAmount, dihedralAngle);
+        try {
+            const ps = new URLSearchParams(window.location.search);
+            ps.set('factor', String(thicknessFactor));
+            ps.set('mode', 'cinematic');
+            history.replaceState(null, '', '?' + ps.toString());
+        } catch (e) { }
     });
 
     shiftSlider.slider.addEventListener('input', (e) => {
@@ -289,6 +344,12 @@ export function animateFoil(scene, foil, renderer, camera, controls, duration =
         shiftSlider.valueDisplay.textContent = shiftAmount.toFixed(2);
         controller.applySpanMorph(startPercent, thicknessFactor, 40, shiftAmount, dihedralAngle);
         rightController.applySpanMorph(startPercent, thicknessFactor, 40, shiftAmount, dihedralAngle);
+        try {
+            const ps = new URLSearchParams(window.location.search);
+            ps.set('shift', String(shiftAmount));
+            ps.set('mode', 'cinematic');
+            history.replaceState(null, '', '?' + ps.toString());
+        } catch (e) { }
     });
 
     dihedralSlider.slider.addEventListener('input', (e) => {
@@ -297,6 +358,12 @@ export function animateFoil(scene, foil, renderer, camera, controls, duration =
         dihedralSlider.valueDisplay.textContent = degrees.toFixed(0) + '°';
         controller.applySpanMorph(startPercent, thicknessFactor, 40, shiftAmount, dihedralAngle);
         rightController.applySpanMorph(startPercent, thicknessFactor, 40, shiftAmount, dihedralAngle);
+        try {
+            const ps = new URLSearchParams(window.location.search);
+            ps.set('dihedral', String(degrees));
+            ps.set('mode', 'cinematic');
+            history.replaceState(null, '', '?' + ps.toString());
+        } catch (e) { }
     });
 
     // --- HUD Overlay ---
diff --git a/frontend/nacaprofile.js b/frontend/nacaprofile.js
index 762ee63..ca16dcb 100644
--- a/frontend/nacaprofile.js
+++ b/frontend/nacaprofile.js
@@ -65,3 +65,98 @@ export function naca4Coordinates(code, chord = 1, n = 200) {
     const shifted = coords.map(p => new THREE.Vector2(p.x - chord / 2, p.y));
     return shifted;
 }
+
+// Approximate NACA 5-digit support (initial implementation).
+// NOTE: This is an initial, compatible generator that maps a 5-digit code
+// into a camber/thickness set and reuses the 4-digit camber logic. It is
+// intentionally conservative so we can test UI and wiring first. If you
+// want the full airfoiltools-accurate 5-digit equations, I will replace
+// this implementation with the standard K1/K2-based formulation next.
+export function naca5Coordinates(code, chord = 1, n = 200) {
+    const s = String(code).replace(/\D/g, '').padStart(5, '0');
+    const L = parseInt(s[0], 10); // lift coefficient code (L -> Cl = L * 3/20)
+    const P = parseInt(s[1], 10); // position code (P -> p = P/20)
+    const Q = parseInt(s[2], 10); // reflex flag (0 = normal, 1 = reflex)
+    const t = parseInt(s.slice(3, 5), 10) / 100.0; // thickness
+
+    // design lift coefficient and linear scaling from base CL=0.3 used in tables
+    const Cl = (L * 3.0) / 20.0; // e.g. L=2 -> Cl=0.3
+    const scale = Cl / 0.3; // multiply k1/k2 by this scale
+
+    // position of maximum camber (p) and table key
+    const p = P / 20.0; // e.g. P=3 -> p=0.15
+    const key = String(P * 5); // 3 -> '15'
+
+    // Tables from AirfoilTools / NACA documentation
+    const standard = {
+        '5': { r: 0.10, k1: 0.0580 },
+        '10': { r: 0.20, k1: 0.1260 },
+        '15': { r: 0.30, k1: 0.2025 },
+        '20': { r: 0.40, k1: 0.2900 },
+        '25': { r: 0.50, k1: 0.3910 }
+    };
+    const reflex = {
+        '10': { r: 0.20, k1: 0.1300, k2k1: 0.000764 },
+        '15': { r: 0.30, k1: 0.2170, k2k1: 0.00677 },
+        '20': { r: 0.40, k1: 0.3180, k2k1: 0.0303 },
+        '25': { r: 0.50, k1: 0.4410, k2k1: 0.1355 }
+    };
+
+    // choose table entry
+    let entry;
+    let isReflex = (Q === 1);
+    if (isReflex) entry = reflex[key] || reflex['15'];
+    else entry = standard[key] || standard['15'];
+
+    const r = entry.r;
+    const k1 = (entry.k1 || 0) * Math.max(0, scale);
+    const k2 = (isReflex && entry.k2k1) ? (k1 * entry.k2k1) : 0;
+
+    // camber line and slope functions for NACA 5-digit
+    function yc_and_dyc(x) {
+        // x is fraction of chord [0..1]
+        if (x < r) {
+            // polynomial region
+            const yc = (k1 / 6) * (Math.pow(x, 3) - 3 * r * Math.pow(x, 2) + Math.pow(r, 2) * (3 - r) * x) + (k2 ? (k2 / 6) * Math.pow(1 - x, 3) : 0);
+            const dyc = (k1 / 6) * (3 * Math.pow(x, 2) - 6 * r * x + Math.pow(r, 2) * (3 - r)) - (k2 ? (k2 / 2) * Math.pow(1 - x, 2) : 0);
+            return { yc, dyc };
+        } else {
+            // linear + possible reflex term
+            const yc = (k1 / 6) * Math.pow(r, 3) * (1 - x) + (k2 ? (k2 / 6) * Math.pow(1 - x, 3) : 0);
+            const dyc = -(k1 / 6) * Math.pow(r, 3) - (k2 ? (k2 / 2) * Math.pow(1 - x, 2) : 0);
+            return { yc, dyc };
+        }
+    }
+
+    const ptsUpper = [];
+    const ptsLower = [];
+
+    // cosine spacing for better leading-edge resolution
+    for (let i = 0; i <= n; i++) {
+        const beta = (i / n) * Math.PI;
+        const x = (1 - Math.cos(beta)) / 2 * chord; // 0..chord
+        const xf = x / chord;
+
+        // thickness distribution (same as 4-digit standard)
+        const yt = (t * chord / 0.2) * (0.2969 * Math.sqrt(xf) - 0.1260 * xf - 0.3516 * Math.pow(xf, 2) + 0.2843 * Math.pow(xf, 3) - 0.1015 * Math.pow(xf, 4));
+
+        const { yc, dyc } = yc_and_dyc(xf);
+        const theta = Math.atan(dyc);
+
+        const xu = x - yt * Math.sin(theta);
+        const yu = yc * chord + yt * Math.cos(theta);
+
+        const xl = x + yt * Math.sin(theta);
+        const yl = yc * chord - yt * Math.cos(theta);
+
+        ptsUpper.push(new THREE.Vector2(xu, yu));
+        ptsLower.push(new THREE.Vector2(xl, yl));
+    }
+
+    const coords = [];
+    for (let i = 0; i < ptsUpper.length; i++) coords.push(ptsUpper[i]);
+    for (let i = ptsLower.length - 1; i >= 0; i--) coords.push(ptsLower[i]);
+
+    const shifted = coords.map(p => new THREE.Vector2(p.x - chord / 2, p.y));
+    return shifted;
+}
diff --git a/frontend/utils.js b/frontend/utils.js
index 019ca52..bea3572 100644
--- a/frontend/utils.js
+++ b/frontend/utils.js
@@ -1,11 +1,21 @@
 import * as THREE from 'three';
+import { naca4Coordinates, naca5Coordinates } from './nacaprofile.js';
 
-export function addSpanMorphUI(params, foil, naca4Coordinates) {
+export function addSpanMorphUI(params, foil, coordsFunc = null, options = {}) {
     let currentFoil = foil;
+    const { appendPanel = true } = options;
+    // Optional initial span morph values (start percent 0-1, factor, slices, shift, dihedral radians)
+    const initStart = (typeof options.startPercent === 'number') ? options.startPercent : 0.5;
+    const initFactor = (typeof options.thicknessFactor === 'number') ? options.thicknessFactor : 1.0;
+    const initSlices = (typeof options.slices === 'number') ? options.slices : 40;
+    const initShift = (typeof options.shiftAmount === 'number') ? options.shiftAmount : 0;
+    const initDihedral = (typeof options.dihedralAngle === 'number') ? options.dihedralAngle : 0;
 
     // --- Span Morph Geometry ---
     function createSpanMorphGeometry(startPercent = 0.5, thicknessFactor = 1.0, slices = 40, shiftAmount = 0, dihedralAngle = 0) {
-        let shape2D = naca4Coordinates(params.naca, params.chord, params.points);
+        // choose generator based on current params.naca length; prefer 5-digit if available
+        const use5 = String(params.naca).replace(/\D/g, '').length === 5;
+        let shape2D = use5 ? naca5Coordinates(params.naca, params.chord, params.points) : naca4Coordinates(params.naca, params.chord, params.points);
 
         if (shape2D.length > 1) {
             const first = shape2D[0];
@@ -145,35 +155,33 @@ export function addSpanMorphUI(params, foil, naca4Coordinates) {
     }
 
     const startInput = document.createElement('input');
-    startInput.type = 'number'; startInput.min = 0; startInput.max = 100; startInput.step = 1; startInput.value = 50; startInput.style.width = '100%';
+    startInput.type = 'number'; startInput.min = 0; startInput.max = 100; startInput.step = 1; startInput.value = Math.round(initStart * 100); startInput.style.width = '100%';
 
     const factorInput = document.createElement('input');
-    factorInput.type = 'number'; factorInput.min = 0.1; factorInput.max = 3; factorInput.step = 0.01; factorInput.value = 1.0; factorInput.style.width = '100%';
+    factorInput.type = 'number'; factorInput.min = 0.1; factorInput.max = 3; factorInput.step = 0.01; factorInput.value = initFactor; factorInput.style.width = '100%';
 
     const slicesInput = document.createElement('input');
-    slicesInput.type = 'number'; slicesInput.min = 2; slicesInput.max = 200; slicesInput.step = 1; slicesInput.value = 40; slicesInput.style.width = '100%';
+    slicesInput.type = 'number'; slicesInput.min = 2; slicesInput.max = 200; slicesInput.step = 1; slicesInput.value = initSlices; slicesInput.style.width = '100%';
 
     const shiftInput = document.createElement('input');
-    shiftInput.type = 'number'; shiftInput.min = -5; shiftInput.max = 5; shiftInput.step = 0.01; shiftInput.value = 0.0; shiftInput.style.width = '100%';
+    shiftInput.type = 'number'; shiftInput.min = -5; shiftInput.max = 5; shiftInput.step = 0.01; shiftInput.value = initShift; shiftInput.style.width = '100%';
 
     const dihedralInput = document.createElement('input');
-    dihedralInput.type = 'number'; dihedralInput.min = -45; dihedralInput.max = 45; dihedralInput.step = 0.1; dihedralInput.value = 0; dihedralInput.style.width = '100%';
+    dihedralInput.type = 'number'; dihedralInput.min = -45; dihedralInput.max = 45; dihedralInput.step = 0.1; dihedralInput.value = initDihedral * 180 / Math.PI; dihedralInput.style.width = '100%';
 
     const applyBtn = document.createElement('button');
     applyBtn.textContent = 'Span Morph Uygula'; applyBtn.style.width = '100%'; applyBtn.style.padding = '6px'; applyBtn.style.cursor = 'pointer';
 
-    const resetBtn = document.createElement('button');
-    resetBtn.textContent = 'Sıfırla (varsayılan)'; resetBtn.style.width = '100%'; resetBtn.style.padding = '6px'; resetBtn.style.marginTop = '6px'; resetBtn.style.cursor = 'pointer';
-
     panel.appendChild(row('Başlangıç (%) (0=root,100=tip)', startInput));
     panel.appendChild(row('Kalınlık Faktörü (1 = orijinal)', factorInput));
     panel.appendChild(row('Dilimler (sweep slices)', slicesInput));
     panel.appendChild(row('Kaydırma (X, chord birimlerinde)', shiftInput));
     panel.appendChild(row('Dihedral Açısı (°)', dihedralInput));
     panel.appendChild(applyBtn);
-    panel.appendChild(resetBtn);
 
-    // document.body.appendChild(panel);
+    if (appendPanel) {
+        document.body.appendChild(panel);
+    }
 
     applyBtn.addEventListener('click', () => {
         const start = Math.max(0, Math.min(100, parseFloat(startInput.value) || 50)) / 100;
@@ -184,10 +192,24 @@ export function addSpanMorphUI(params, foil, naca4Coordinates) {
         applySpanMorph(start, factor, slices, shift, dihedral);
     });
 
-    resetBtn.addEventListener('click', () => {
-        startInput.value = 50; factorInput.value = 1.0; slicesInput.value = 40; shiftInput.value = 0.0; dihedralInput.value = 0;
+    function resetDefaults() {
+        startInput.value = Math.round(0.5 * 100);
+        factorInput.value = 1.0;
+        slicesInput.value = 40;
+        shiftInput.value = 0.0;
+        dihedralInput.value = 0;
         applyBtn.click();
-    });
+    }
+
+    function getCurrentValues() {
+        return {
+            startPercent: Math.max(0, Math.min(100, parseFloat(startInput.value) || 50)) / 100,
+            thicknessFactor: Math.max(0.01, parseFloat(factorInput.value) || 1.0),
+            slices: Math.max(2, parseInt(slicesInput.value, 10) || 40),
+            shiftAmount: parseFloat(shiftInput.value) || 0,
+            dihedralAngle: (parseFloat(dihedralInput.value) || 0) * Math.PI / 180
+        };
+    }
 
     let debounce = null;
     [startInput, factorInput, slicesInput, shiftInput, dihedralInput].forEach(inp => {
@@ -199,5 +221,5 @@ export function addSpanMorphUI(params, foil, naca4Coordinates) {
 
     applyBtn.click();
 
-    return { applySpanMorph, setFoilMesh };
+    return { applySpanMorph, setFoilMesh, resetDefaults, getCurrentValues };
 }
diff --git a/frontend/wing.js b/frontend/wing.js
index 9b1fb21..a8bb146 100644
--- a/frontend/wing.js
+++ b/frontend/wing.js
@@ -1,7 +1,7 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
 import { addSpanMorphUI } from './utils.js';
-import { naca4Coordinates } from './nacaprofile.js';
+import { naca4Coordinates, naca5Coordinates } from './nacaprofile.js';
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 import { animateFoil } from './animate.foil.js';
 
@@ -15,6 +15,29 @@ const params = {
     scale: 3.0,     // visual scale
 };
 
+// initialize params from URL query string if present so mode switches preserve state
+(function initParamsFromURL() {
+    try {
+        const p = new URLSearchParams(window.location.search);
+        const n = p.get('naca');
+        if (n) params.naca = String(n).replace(/\D/g, '');
+        const chord = parseFloat(p.get('chord'));
+        if (!Number.isNaN(chord)) params.chord = chord;
+        const points = parseInt(p.get('points'), 10);
+        if (!Number.isNaN(points)) params.points = points;
+        const depth = parseFloat(p.get('depth'));
+        if (!Number.isNaN(depth)) params.depth = depth;
+        const scale = parseFloat(p.get('scale'));
+        if (!Number.isNaN(scale)) params.scale = scale;
+    } catch (e) {
+        // ignore
+    }
+})();
+
+// read mode from URL query param ?mode=cinematic or ?mode=normal (default normal)
+const urlParams = new URLSearchParams(window.location.search);
+const startMode = (urlParams.get('mode') || 'normal').toLowerCase();
+
 // THREE.js scene
 const scene = new THREE.Scene();
 scene.background = new THREE.Color(0x203040);
@@ -54,7 +77,8 @@ scene.add(dir);
 
 // build airfoil mesh (updates in-place if a foil group already exists in the scene)
 function buildAirfoilMesh() {
-    const shapePts = naca4Coordinates(params.naca, params.chord, params.points);
+    const coordsFunc = (String(params.naca).replace(/\D/g, '').length === 5) ? naca5Coordinates : naca4Coordinates;
+    const shapePts = coordsFunc(params.naca, params.chord, params.points);
     const shape = new THREE.Shape(shapePts);
 
     // Extrude to give some span-wise thickness
@@ -138,7 +162,27 @@ scene.add(foil);
 
 // create span morph UI once and keep the controller so we can reattach a new foil
 // when geometry is rebuilt without recreating the UI (which would reset values)
-let spanMorphController = addSpanMorphUI(params, foil, naca4Coordinates);
+// create span morph UI and show panel in normal mode only
+const initialCoordsFunc = (String(params.naca).replace(/\D/g, '').length === 5) ? naca5Coordinates : naca4Coordinates;
+// read initial span-morph params from URL as well
+function readSpanParamsFromURL() {
+    const p = new URLSearchParams(window.location.search);
+    const s = parseFloat(p.get('start'));
+    const f = parseFloat(p.get('factor'));
+    const slices = parseInt(p.get('slices'), 10);
+    const shift = parseFloat(p.get('shift'));
+    const dihedral = parseFloat(p.get('dihedral'));
+    const out = {};
+    if (!Number.isNaN(s)) out.startPercent = Math.max(0, Math.min(1, s));
+    if (!Number.isNaN(f)) out.thicknessFactor = f;
+    if (!Number.isNaN(slices)) out.slices = slices;
+    if (!Number.isNaN(shift)) out.shiftAmount = shift;
+    if (!Number.isNaN(dihedral)) out.dihedralAngle = dihedral * Math.PI / 180;
+    return out;
+}
+
+const spanInit = readSpanParamsFromURL();
+let spanMorphController = addSpanMorphUI(params, foil, initialCoordsFunc, Object.assign({ appendPanel: startMode === 'normal' }, spanInit));
 
 // rebuild helper that disposes previous geometry/materials properly (module scope)
 function rebuildFoil() {
@@ -252,13 +296,16 @@ function onWindowResize() {
         return row;
     }
 
-    // NACA as numeric input (will be zero-padded to 4 digits)
+    // NACA input: allow 4 or 5 digits (text input, digits-only)
     const nacaInput = document.createElement('input');
-    nacaInput.type = 'number';
-    nacaInput.min = 0;
-    nacaInput.max = 9999;
-    nacaInput.value = parseInt(params.naca, 10);
+    nacaInput.type = 'text';
+    nacaInput.maxLength = 5;
+    nacaInput.value = params.naca;
     nacaInput.style.width = '100%';
+    // allow only digits while typing
+    nacaInput.addEventListener('input', () => {
+        nacaInput.value = nacaInput.value.replace(/[^0-9]/g, '').slice(0, 5);
+    });
 
     const chordInput = document.createElement('input');
     chordInput.type = 'number';
@@ -288,36 +335,59 @@ function onWindowResize() {
     scaleInput.value = params.scale;
     scaleInput.style.width = '100%';
 
-    // create apply button
-    const applyBtn = document.createElement('button');
-    applyBtn.textContent = 'Apply';
-    Object.assign(applyBtn.style, {
-        width: '100%',
-        padding: '6px 8px',
-        marginTop: '6px',
-        cursor: 'pointer',
-        background: '#2b8cff',
-        color: '#fff',
-        border: 'none',
-        borderRadius: '4px',
-    });
+    // inputs will auto-apply on change; no visible Apply button needed
 
     // assemble panel rows
-    panel.appendChild(makeRow('NACA (4-digit)', nacaInput));
+    panel.appendChild(makeRow('NACA (4/5-digit)', nacaInput));
     panel.appendChild(makeRow('Chord', chordInput));
     panel.appendChild(makeRow('Points', pointsInput));
     panel.appendChild(makeRow('Depth', depthInput));
     panel.appendChild(makeRow('Scale', scaleInput));
-    panel.appendChild(applyBtn);
+    // Note: Apply button removed — changes are applied automatically
+
+    // Note: standalone Reset button removed — Normal button performs reset
+
+    // Mode buttons: switch between normal and cinematic by reloading with ?mode=
+    const normalBtn = document.createElement('button');
+    normalBtn.textContent = 'Reset';
+    Object.assign(normalBtn.style, { width: '48%', padding: '6px', marginRight: '4%', marginTop: '8px', cursor: 'pointer', background: '#f0f0f0', color: '#000', border: '1px solid #444' });
+    normalBtn.addEventListener('click', () => {
+        // only reset span-morph defaults (do not change mode)
+        if (spanMorphController && typeof spanMorphController.resetDefaults === 'function') {
+            spanMorphController.resetDefaults();
+        } else {
+            console.warn('Span morph controller not available to reset');
+        }
+    });
 
-    // document.body.appendChild(panel);
+    const cinematicBtn = document.createElement('button');
+    cinematicBtn.textContent = 'Cinematic Mode (Ctrl+M)';
+    Object.assign(cinematicBtn.style, { width: '48%', padding: '6px', marginTop: '8px', cursor: 'pointer', background: '#2b8cff', color: '#fff', border: 'none' });
+    cinematicBtn.addEventListener('click', () => { window.location.search = '?mode=cinematic'; });
 
-    // apply button (reads numeric inputs, sanitizes, updates params and rebuilds)
-    applyBtn.addEventListener('click', () => {
-        // NACA: zero-pad to 4 digits
-        let nacaVal = parseInt(nacaInput.value, 10) || 0;
-        nacaVal = Math.max(0, Math.min(9999, nacaVal));
-        const nacaStr = String(nacaVal).padStart(4, '0');
+    const btnRow = document.createElement('div');
+    btnRow.style.display = 'flex';
+    btnRow.appendChild(normalBtn);
+    btnRow.appendChild(cinematicBtn);
+    panel.appendChild(btnRow);
+
+    // attach main control panel only in normal mode
+    if (startMode === 'normal') {
+        document.body.appendChild(panel);
+    }
+
+    // auto-apply function: read inputs and rebuild immediately (debounced)
+    function applyInputs() {
+        // NACA: accept 4 or 5 digit codes
+        const raw = String(nacaInput.value || '').replace(/\D/g, '');
+        let nacaStr = params.naca;
+        if (raw.length === 5) {
+            nacaStr = raw;
+        } else {
+            let nacaVal = parseInt(raw, 10) || 0;
+            nacaVal = Math.max(0, Math.min(9999, nacaVal));
+            nacaStr = String(nacaVal).padStart(4, '0');
+        }
 
         params.naca = nacaStr;
         params.chord = Math.max(0.001, parseFloat(chordInput.value) || params.chord);
@@ -333,13 +403,37 @@ function onWindowResize() {
         if (spanMorphController && typeof spanMorphController.setFoilMesh === 'function') {
             spanMorphController.setFoilMesh(foil);
         }
-    });
 
-    // optional: rebuild live while editing (debounced)
+        // Update the URL (without reloading) so mode switches preserve latest values
+        try {
+            const ps = new URLSearchParams(window.location.search);
+            ps.set('naca', params.naca);
+            ps.set('chord', String(params.chord));
+            ps.set('points', String(params.points));
+            ps.set('depth', String(params.depth));
+            ps.set('scale', String(params.scale));
+            // span morph values
+            if (spanMorphController && typeof spanMorphController.getCurrentValues === 'function') {
+                const s = spanMorphController.getCurrentValues();
+                ps.set('start', String(s.startPercent));
+                ps.set('factor', String(s.thicknessFactor));
+                ps.set('slices', String(s.slices));
+                ps.set('shift', String(s.shiftAmount));
+                ps.set('dihedral', String(s.dihedralAngle * 180 / Math.PI));
+            }
+            // preserve mode param if present
+            const mode = (new URLSearchParams(window.location.search)).get('mode');
+            if (mode) ps.set('mode', mode);
+            history.replaceState(null, '', '?' + ps.toString());
+        } catch (e) {
+            // ignore URL update failures
+        }
+    }
+
     let debounceTimer = null;
     function scheduleApply() {
         clearTimeout(debounceTimer);
-        debounceTimer = setTimeout(() => applyBtn.click(), 250);
+        debounceTimer = setTimeout(() => applyInputs(), 250);
     }
     [nacaInput, chordInput, pointsInput, depthInput, scaleInput].forEach((inp) => {
         inp.addEventListener('input', scheduleApply);
@@ -376,6 +470,25 @@ function animate() {
 // Normal görünüme dönmek için aşağıdaki satırı yorum yap ve aşağıdaki animate() satırının yorumunu kaldır
 // animate();  // Normal mod: Mouse ile kamera kontrolü
 
-// Sinematik mod: Otomatik kamera + Manuel kanat kontrolü
-// OrbitControls'u da gönderiyoruz ki animasyon bitince tekrar aktif olabilsin
-animateFoil(scene, foil, renderer, camera, controls, 30, 60);
\ No newline at end of file
+// Start the chosen mode
+if (startMode === 'cinematic') {
+    // cinematic mode
+    animateFoil(scene, foil, renderer, camera, controls, 30, 60);
+} else {
+    // normal interactive mode
+    animate();
+}
+
+// Global shortcut to toggle mode: Ctrl+M or Cmd+M
+window.addEventListener('keydown', (e) => {
+    if ((e.ctrlKey || e.metaKey) && (e.key === 'm' || e.key === 'M')) {
+        e.preventDefault();
+        // determine current mode from the live URL (don't use the startup snapshot)
+        const paramsNow = new URLSearchParams(window.location.search);
+        const cur = (paramsNow.get('mode') || 'normal').toLowerCase();
+        const next = (cur === 'cinematic') ? 'normal' : 'cinematic';
+        paramsNow.set('mode', next);
+        // preserve other query params while updating mode
+        window.location.search = '?' + paramsNow.toString();
+    }
+});
\ No newline at end of file
-- 
2.51.2

